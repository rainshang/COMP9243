Milestone 1

commonlib.h
--a common lib for both dsm.c and sm.c to reduce code redundancy. Specifiaclly, there are two things worthy to be mentioned,
    --'protocol_write' and 'protocol_read', they implement a protocol above TCP, to make sure one read operation exact the data one write does, for any filedesciptor message delivery, such as socket and pipe
    --'generate_client_msg' and 'split_client_msg' is a protocol above the protocol above, which is to wrap the msg sent from client to server. Server will deny any messages not following this protocol

param.h param.c
--to process the arguments when execute 'dsm'. The struct Parameters is to store the basic arguments when call the function dsm. The function parameters_init() will initialize and allocate the memory for the arguments. The function extract_host_names() will open the hostfile and store all nodes. The main function is Parameters *parse_argv(), which will store all the information from the command line and return the struct. Finally, it also contains log functions, they will write what server and client do to the log file.

dsm.c
--the so-called 'server' or 'allocator'. It fork()s N process to execute ssh command to run the 'EXECUTABLE FILE' on remote(or local) host, wait for the N client hosts to connect back to server via TCP and then runs an infinite loop to listen the sockets one by one and processe them in order. This mechanism is easier to manage the message synchronously than fork()ing N more new processes for the N sockets.

sm.c
--when called by server via ssh it connect back to server and fork()s a new process to listen to the socket infinitely. So there are two process in a client which includes this SM library API. An anonymous pipe is created for the communication between them. For example, in 'sm_barrier', parent process requests socket listening by sending message via pipe to child process. Thus, child process stops reading socket to let parent to handle it. After parent process receives the barrier synchronization message from server, it return the socket listening permission to child process.


Milestone 2

#import a third party verctor lib, https://github.com/rxi/vec

--when 'sm_node_init', each node calls 'mmap' to get available shared memory address(sm_addr), then send it the allocator. Allocator selects the MINIMUM one as the global shared memory start address, then returns it to nodes. Every node re-mmap by it and should get a new smaller address (aligned by page_size), which should be same. Then send to allocator again to double check
--when 'sm_malloc', node sends the size to malloc to allocator, allocator do 'g_smp+=size' and turns the 'g_smp' to each node one by one. Thus, every 'sm_malloc' memory will never overlap.
--then each node calls 'sm_bcast' to broadcast its new memory, including the address, size and data. When other nodes receives it, they 'mmap' with the given address and size, then fulfill the data, like a copy. What should be noticed is that this memory should be 'mprotect(PORT_NONE)' because it is 'on other node'
--allocator should save read permission lists(r_list) of N node ids and write permiss node id for each address
--when read fault sigal of one address generated, get latest node id in 'r_list', release its owner ship and read permission. Old updates the data to new, then the new node gets the read permission.
--similar operation for writting fault